# Implementation

## Goal

1. Online event-based diff test
2. Decoupled
3. Serialization

## Detail

When doing a diff test, we run the simulator first and record the state of the current memory, registers, and CSR into `State` after each instruction is executed.

Of course, we may want to filter out instructions that are not of interest. For example, maybe we only want to test the V extension.

Serializing the state of the entire memory may sound scary, but we can set the initial state of the memory to all zeros. In this way, for usually a small-sized test program, there is a high probability that the memory is a piece of sparse binary data, which can be effectively compressed. Maybe just performing run-length encoding would suffice.

After the simulator execution is completed, we have a `State` sequence. We can serialize this sequence to a file (e.g. via SQLite), which can be used later.

Here is an exemplary definition of a `State`:

```proto
message State {
    uint32 instruction = 1;
    uint64 pc = 2;

    // Run-length encoded byte array.
    message Piece {
        uint32 len = 1;
        bytes data = 2;
    }

    repeated Piece pieces = 3;
}
```

As you can see, we treat the entire state as a byte array and then use run-length encoding to compress it. Users of the framework need to concatenate the registers and memory etc. together by themselves.

Anyway, once having the `State` sequence, we can run RTL. `Event`s will be generated during the running of RTL. There is only one thing an `Event` can do, which is to modify the `State` (i.e. the byte array).

Here is an exemplary definition of an `Event`:

```proto
message Event {
    enum Type {
        MEM_WRITE = 0;
        REG_WRITE = 1;
    }

    uint32 fingerprint = 1;
    Type type = 2;
    uint32 offset = 3;
    bytes data = 4;
}
```

Events are generated during RTL running, and we must know which `State` a certain `Event` corresponds to. Here we assume that instructions issued earlier always generate events earlier, and every `Event` generated by RTL must have a fingerprint (e.g. issue index). Then a map can be maintained for each `State`, e.g.

```javascript
{
    mem_write_fingerprint: 2,
    reg_write_fingerprint: 3,
}
```

When we encountered an `Event` with a new fingerprint for all the uncommitted states, it must belong to the first `State`. Otherwise, we can find the corresponding `State` using the map.

Since all events are associated with a certain `State`, after the `State` is committed, we can calculate a new byte array based on the byte array of the previous `State` and the events of the current `State`, and compare it with the byte array of the current `State`.
