# Implementation

This is a co-simulation framework implementation proposal for RISC-V cores.

## Goal

1. Online event-based diff test
2. Decoupling between RTL and the functional simulator. This means:
    1. We do not restrict users to a specific functional emulator
    2. We do not restrict users to a specific RTL programming interface
3. Serialization. We use protocol buffers to serialize the states generated by the functional simulator to disk. This saves us from having to run the same program repeatedly, and more importantly allows us to start testing from any breakpoint.

## Existing solutions

### [Dromajo](https://github.com/chipsalliance/dromajo)

Dromajo is a co-simulation framework developed by Esperanto Technology. It is essentially a RV64GC emulator designed for RTL co-simulation. Here is an overview of its usage: [cva6-dromajo-integration.md](https://github.com/chipsalliance/dromajo/blob/master/doc/cva6-dromajo-integration.md). We wanted a similar framework, but we wanted to use an officially maintained emulator such as Spike or sail-riscv, or whatever we like. And we hope to support not only RISC-V cores, but also RISC-V coprocessors (such as V).

### [sequencer/vector](https://github.com/sequencer/vector)

`sequencer/vector` contains a [co-simulation verification framework](https://github.com/sequencer/vector/tree/master/tests/emulator/src) for the V coprocessor based on Spike and DPI. It implements the functionality well, but does not support serialization, and the simulator and RTL are coupled to each other. We eventually want to replace it with the current proposal.

## Detail

When doing a diff test, we run the simulator first and record the state of the current memory, registers, and CSR into `State` after each instruction is executed.

Of course, we may want to filter out instructions that are not of interest. For example, maybe we only want to test the V extension.

Serializing the state of the entire memory may sound scary, but we can set the initial state of the memory to all zeros. In this way, for usually a small-sized test program, there is a high probability that the memory is a piece of sparse binary data, which can be effectively compressed. Maybe just performing run-length encoding would suffice.

After the simulator execution is completed, we have a `State` sequence. We can serialize this sequence to a file (e.g. via SQLite), which can be used later.

Here is an exemplary definition of a `State`:

```proto
message State {
    uint32 instruction = 1;
    uint64 pc = 2;

    // Run-length encoded byte array.
    message Piece {
        uint32 len = 1;
        bytes data = 2;
    }

    repeated Piece pieces = 3;
}
```

As you can see, we treat the entire state as a byte array and then use run-length encoding to compress it. Users of the framework need to concatenate the registers and memory etc. together by themselves.

Anyway, once having the `State` sequence, we can run RTL. `Event`s will be generated during the running of RTL. There is only one thing an `Event` can do, which is to modify the `State` (i.e. the byte array).

Here is an exemplary definition of an `Event`:

```proto
message Event {
    enum Type {
        MEM_WRITE = 0;
        REG_WRITE = 1;
    }

    uint32 fingerprint = 1;
    Type type = 2;
    uint32 offset = 3;
    bytes data = 4;
}
```

Events are generated during RTL running, and we must know which `State` a certain `Event` corresponds to. Here we assume that instructions issued earlier always generate events earlier, and every `Event` generated by RTL must have a fingerprint (e.g. issue index). Then a map can be maintained for each `State`, e.g.

```javascript
{
    mem_write_fingerprint: 2,
    reg_write_fingerprint: 3,
}
```

When we encountered an `Event` with a new fingerprint for all the uncommitted states, it must belong to the first `State`. Otherwise, we can find the corresponding `State` using the map.

Since all events are associated with a certain `State`, after the `State` is committed, we can calculate a new byte array based on the byte array of the previous `State` and the events of the current `State`, and compare it with the byte array of the current `State`.
